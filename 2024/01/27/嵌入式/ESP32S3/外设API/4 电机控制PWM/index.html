<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Hexo Theme Redefine"><meta name="author" content="Chepey"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="canonical" href="http://chepey.github.io/2024/01/27/嵌入式/esp32s3/外设api/4 电机控制pwm/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="电机控制PWM电机控制外设（MCPWM）是一个多功能PWM波发生器，它包含很多子模块。这些模块使它很好地应用在电力电子项目中。 电机控制外设可以用在以下经典场合：  数字电机控制（有刷、无刷直流电机）、舵机 开关电源 功率数模转换（占空比等于DAC模拟量） 计算外部脉冲宽度，并将之转化为其他模拟量（速度、距离） 为矢量控制（FOC）生成空间向量PWM  下图中包含主要的子模块： ![img](E:"><meta property="og:type" content="article"><meta property="og:title" content="4 电机控制PWM"><meta property="og:url" content="http://chepey.github.io/2024/01/27/%E5%B5%8C%E5%85%A5%E5%BC%8F/ESP32S3/%E5%A4%96%E8%AE%BEAPI/4%20%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6PWM/index.html"><meta property="og:site_name" content="Welcome to Chepey&#39;s Blog"><meta property="og:description" content="电机控制PWM电机控制外设（MCPWM）是一个多功能PWM波发生器，它包含很多子模块。这些模块使它很好地应用在电力电子项目中。 电机控制外设可以用在以下经典场合：  数字电机控制（有刷、无刷直流电机）、舵机 开关电源 功率数模转换（占空比等于DAC模拟量） 计算外部脉冲宽度，并将之转化为其他模拟量（速度、距离） 为矢量控制（FOC）生成空间向量PWM  下图中包含主要的子模块： ![img](E:"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-01-27T09:03:00.000Z"><meta property="article:modified_time" content="2024-02-01T03:13:52.373Z"><meta property="article:author" content="chepey"><meta property="article:tag" content="ESP32"><meta property="article:tag" content="ESP-IDF"><meta name="twitter:card" content="summary"><link rel="icon" type="image/png" href="/images/favicon.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png"><meta name="theme-color" content="#A31F34"><link rel="shortcut icon" href="/images/favicon.png"><title>4 电机控制PWM - Chepey&#39;s Blog</title><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/assets/build/styles.css"><link rel="stylesheet" href="/fonts/fonts.css"><link rel="stylesheet" href="/fonts/Satoshi/satoshi.css"><link rel="stylesheet" href="/fonts/Chillax/chillax.css"><script id="hexo-configurations">window.config={hostname:"chepey.github.io",root:"/",language:"zh-CN",path:"search.xml"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[]},code_block:{copy:!0,style:"mac",font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:3,number:!0,expand:!0,init_open:!0},copyright:!0,lazyload:!1,recommendation:{enable:!1,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#A31F34",secondary:"#1b143e"},global:{fonts:{chinese:{enable:!1,family:null,url:null},english:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!0},scroll_progress:{bar:!0,percentage:!0},website_counter:{url:"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,open_graph:!0,google_analytics:{enable:!1,id:null}},home_banner:{enable:!0,style:"fixed",image:{light:"/images/bk2.jpg",dark:"/images/bk2.jpg"},title:"Welcome to Chepey's Blog",subtitle:{text:["3D打印","嵌入式开发","DIY","二次元","etc"],hitokoto:{enable:!1,api:"https://v1.hitokoto.cn"},typing_speed:100,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#1b143e",dark:"#1b143e"},text_style:{title_size:"3.7rem",subtitle_size:"2.5rem",line_height:1.2},custom_font:{enable:!1,family:null,url:null},social_links:{enable:!1,links:{github:null,instagram:null,zhihu:null,twitter:null,email:null},qrs:{weixin:null}}},plugins:{feed:{enable:!1},aplayer:{enable:!1,type:"fixed",audios:[{name:null,artist:null,url:null,cover:null}]},mermaid:{enable:!1,version:"9.3.0"}},version:"2.5.0",navbar:{auto_hide:!1,color:{left:"#332847",right:"#af6e79",transparency:35},links:{Home:{path:"/",icon:"fa-regular fa-house"},"档案":{path:"/archives",icon:"fa-regular fa-archive"},"目录":{path:"/categories",icon:"fa-regular fa-folder"},"标签":{path:"/tags",icon:"fa-regular fa-tags"}},search:{enable:!0,preload:!0}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:null,links:{"档案":{path:"/archives",icon:"fa-regular fa-archive"},"目录":{path:"/categories",icon:"fa-regular fa-folder"},"标签":{path:"/tags",icon:"fa-regular fa-tags"}}},article_date_format:"auto",categories:{enable:!0,limit:5},tags:{enable:!0,limit:5}},footerStart:"2023/10/25 13:02:00"},window.lang_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"},window.data={masonry:!1}</script><link rel="stylesheet" href="/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="/fontawesome/brands.min.css"><link rel="stylesheet" href="/fontawesome/solid.min.css"><link rel="stylesheet" href="/fontawesome/regular.min.css"><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <span class="swup-progress-icon"><i class="fa-solid fa-circle-notch fa-spin"></i></span></div><main class="page-container" id="swup"><div class="main-content-container"><div class="main-content-header"><header class="navbar-container"><div class="navbar-content"><div class="left"><a class="logo-image" href="/"><img src="/images/favicon.png"> </a><a class="logo-title" href="/">Chepey&#39;s Blog</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-regular fa-house"></i> 首页</a></li><li class="navbar-item"><a href="/archives"><i class="fa-regular fa-archive"></i> 档案</a></li><li class="navbar-item"><a href="/categories"><i class="fa-regular fa-folder"></i> 目录</a></li><li class="navbar-item"><a href="/tags"><i class="fa-regular fa-tags"></i> 标签</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer w-full absolute top-0 left-0 bg-background-color"><ul class="drawer-navbar-list flex flex-col justify-start items-center"><li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center"><a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group" href="/"><i class="fa-regular fa-house"></i> 首页</a></li><li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center"><a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group" href="/archives"><i class="fa-regular fa-archive"></i> 档案</a></li><li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center"><a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group" href="/categories"><i class="fa-regular fa-folder"></i> 目录</a></li><li class="drawer-navbar-item text-base my-1.5 flex justify-center items-center"><a class="rounded-3xl py-1.5 px-5 hover:border hover:!text-primary active:!text-primary group" href="/tags"><i class="fa-regular fa-tags"></i> 标签</a></li></ul></div><div class="window-mask"></div></header></div><div class="main-content-body"><div class="main-content"><div class="post-page-container"><div class="article-content-container"><div class="article-title"><h1 class="article-title-regular">4 电机控制PWM</h1></div><div class="article-header flex flex-row gap-2 items-center"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="/images/avatar.jpg"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">Chepey</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv5</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2024-01-27 17:03</span> <span class="mobile">2024-01-27 17:03</span> <span class="hover-info">创建</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2024-02-01 11:13:52</span> <span class="mobile">2024-02-01 11:13:52</span> <span class="hover-info">更新</span> </span><span class="article-categories article-meta-item"><i class="fa-regular fa-folders"></i>&nbsp;<ul><li><a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a>&nbsp;</li><li>></li><li><a href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/ESP32S3/">ESP32S3</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/ESP32/">ESP32</a>&nbsp;</li><li>| <a href="/tags/ESP-IDF/">ESP-IDF</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fa-regular fa-typewriter"></i>&nbsp;<span>9k 字</span> </span><span class="article-min2read article-meta-item"><i class="fa-regular fa-clock"></i>&nbsp;<span>34 分钟</span> </span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><h1 id="电机控制PWM"><a href="#电机控制PWM" class="headerlink" title="电机控制PWM"></a>电机控制PWM</h1><p>电机控制外设（MCPWM）是一个多功能PWM波发生器，它包含很多子模块。这些模块使它很好地应用在电力电子项目中。</p><p>电机控制外设可以用在以下经典场合：</p><ul><li>数字电机控制（有刷、无刷直流电机）、舵机</li><li>开关电源</li><li>功率数模转换（占空比等于DAC模拟量）</li><li>计算外部脉冲宽度，并将之转化为其他模拟量（速度、距离）</li><li>为矢量控制（FOC）生成空间向量PWM</li></ul><p>下图中包含主要的子模块：</p><p>![img](E:\0_VS\6_Blog\chepeys_blog\source_posts\嵌入式\ESP32S3\外设API\4 电机控制PWM\blockdiag-86892b07b250d747563da34c71508176f90bfe15.png)</p><ul><li><strong>MCPWM 定时器</strong>： 最终输出PWM信号的时间基础，它也决定其他模块的事件事件</li><li><strong>MCPWM 操作器</strong>： 负责生成PWM波的关键模块。它由比较器、PWM生成器、死区时间、载波调制组成</li><li><strong>MCPWM 比较器</strong>： 定时器的计数值为比较器的输入，比较器会连续不断地比较用户配置的阈值。当定时计数器输出等于任一阈值时，将会生成一个比较事件，MCPWM生成器从而可以更新它的电平</li><li><strong>MCPWM 生成器</strong>： 一个生成器可以基于多种事件触发方式（定时器/比较器）生成一对（互补的/独立的）PWM波</li><li><strong>MCPWM 故障</strong>: 故将模块主要通过GPIO矩阵检测外部故障情况。一旦故障信号被触发，MCPWM操作器讲强制所有生成器进入一个预先定义的状态，从而保护系统不受到损伤</li><li><strong>MCPWM 同步</strong>： 同步模块的功能为同步多个MCPWM定时器以使不同MCPWM生成器的PWM波具有固定的相位差。同时，同步信号可以来自GPIO矩阵或其他MCPWM定时器</li><li><strong>死区时间</strong>： 本子模块用于为前一步生成的PWM边沿插入外部延时</li><li><strong>载波调制</strong>：载波调制使用高频率载波信号调制PWM生成器和死区时间步骤生成的PWM波。如果你需要使用基于脉冲转换的门驱动器控制功率开关元件，这一步很必要</li><li><strong>刹车</strong>：MCPWM操作器可以设定当特定故障发生时关闭PWM生成器的方法。我们可以根据故障的重要程度选择立即关闭PWM波输出或逐个周期调节PWM波</li><li><strong>MCPWM 捕获</strong>：这是一个独立的子模块，它可以独立于MCPWM操作器运行。本模块由一个专用定时器和几个独立通道组成。每一个通道都连接至GPIO口（GPIO口上的脉冲将会触发捕获定时器存储计数器值，并通过中断通知给用户）。通过这个特性，我们可以精确测量脉冲宽度。并且，捕获定时器也可以被MCPWM同步子模块同步</li></ul><h2 id="功能总览"><a href="#功能总览" class="headerlink" title="功能总览"></a>功能总览</h2><p>描述MCPWM的功能可以被分为以下章节：</p><ul><li>资源分配和初始化：包扩如何分配多种MCPWM对象（定时器、操作器、比较器、生成器等）。这些对象使加下来IO设定和控制功能的基础</li><li>定时器操作和事件：描述MCPWM定时器的控制函数和时间回调</li><li>比较器操作与事件：描述MCPWM比较器的控制函数和时间回调</li><li>生成器动作与事件：描述如何设定由MCPWM定时器和比较器生成的时间种设定生成器的动作</li><li>经典PWM波和生成器配置：解释可由生成器配置产生的一些经典的PWM波</li><li>死区时间：描述设置生成器死区时间的方法</li><li>经典PWM波和死区时间配置：描述一些可以通过配置死区时间可以实现的经典PWM波</li><li>载波调制：描述如何给最终PWM设置高频调制</li><li>故障及刹车动作：描述如何给特定故障事件设置操作器的刹车动作</li><li>生成器强制动作：描述如何强制控制生成器输出电平同步</li><li>同步化：描述如何同步MCPWM时钟并且得到各路PWM信号的固定相位差</li><li>捕获：描述如何使用捕获器模块测量信号脉冲宽度</li><li>功率管理：描述不同时钟源的功率消耗</li><li>IRAM安全：描述可以保证线程安全的API</li><li>Kconfig选项：列出带来不同影响支持的Kconfig选项</li></ul><h2 id="资源分配和初始化"><a href="#资源分配和初始化" class="headerlink" title="资源分配和初始化"></a>资源分配和初始化</h2><p>MCPWM外设由几个子模块组成，每一个子模块由自身的资源分配。</p><h3 id="MCPWM定时器"><a href="#MCPWM定时器" class="headerlink" title="MCPWM定时器"></a>MCPWM定时器</h3><p>我们可以通过<code>mcpwm_new_timer()</code>分配一个MCPWM定时器对象。其参数为<code>mcpwm_timer_config_t</code>结构体。该结构体参数为：</p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N20mcpwm_timer_config_t8group_idE"><code>mcpwm_timer_config_t::group_id</code></a> 确定MCPWM组的ID，这个ID属于[0, <a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/system/soc_caps.html#c.SOC_MCPWM_GROUPS"><code>SOC_MCPWM_GROUPS</code></a> - 1]范围内。注意：分配给不同组的定时器是相互独立的</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N20mcpwm_timer_config_t13intr_priorityE"><code>mcpwm_timer_config_t::intr_priority</code></a> 设置中断优先级。如果设置为0，驱动将会分配一个默认优先级的中断。否则驱动将会使用用户给出的优先级</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N20mcpwm_timer_config_t7clk_srcE"><code>mcpwm_timer_config_t::clk_src</code></a> 为定时器设置时钟源。</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N20mcpwm_timer_config_t13resolution_hzE"><code>mcpwm_timer_config_t::resolution_hz</code></a> 设置定时器的期望分辨率。驱动内部将会设定合适的分频器</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N20mcpwm_timer_config_t10count_modeE"><code>mcpwm_timer_config_t::count_mode</code></a> 设置定时器的计数模式。</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N20mcpwm_timer_config_t12period_ticksE"><code>mcpwm_timer_config_t::period_ticks</code></a> 设定定时器的周期（嘀嗒次数，嘀嗒分辨率设置在<code>resolution_hz</code>中）</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N20mcpwm_timer_config_t22update_period_on_emptyE"><code>mcpwm_timer_config_t::update_period_on_empty</code></a> 设置值当计时器计数为0时是否更新周期值</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N20mcpwm_timer_config_t21update_period_on_syncE"><code>mcpwm_timer_config_t::update_period_on_sync</code></a> 设置当计时器获取同步信号时是否更新周期值</li></ul><p><code>mcpwm_new_timer()</code>当成功时函数将会返回一个指向所分配定时器对象的指针。否则他会返回错误代码。特别地，当没有更多空闲定时器资源时，这个函数将会返回<code>ESP_ERR_NOT_FOUND</code>错误。</p><p>相反，使用<code>mcpwm_del_timer()</code>函数将会释放分配的定时器对象。</p><h3 id="MCPWM操作器"><a href="#MCPWM操作器" class="headerlink" title="MCPWM操作器"></a>MCPWM操作器</h3><p>可以通过<code>mcpwm_new_operator()</code>函数分配一个MCPWM操作器对象。其参数为<code>mcpwm_operator_config_t</code>结构体。该结构体为如下定义：</p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N23mcpwm_operator_config_t8group_idE"><code>mcpwm_operator_config_t::group_id</code></a> 确定MCPWM组ID</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N23mcpwm_operator_config_t13intr_priorityE"><code>mcpwm_operator_config_t::intr_priority</code></a> 设置中断优先级</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N23mcpwm_operator_config_t24update_gen_action_on_tezE"><code>mcpwm_operator_config_t::update_gen_action_on_tez</code></a> 设置当定时器计数为0时是否更新生成器动作。在这里和下面，定时器是指通过<code>mcpwm_operator_connect_timer()</code>函数连接到操作器的定时器</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N23mcpwm_operator_config_t24update_gen_action_on_tepE"><code>mcpwm_operator_config_t::update_gen_action_on_tep</code></a> 设置定时器计数达到上限时，生成器的动作是否改变</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N23mcpwm_operator_config_t25update_gen_action_on_syncE"><code>mcpwm_operator_config_t::update_gen_action_on_sync</code></a> 设置当计时器获取同步信号时是否更新生成器动作</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N23mcpwm_operator_config_t23update_dead_time_on_tezE"><code>mcpwm_operator_config_t::update_dead_time_on_tez</code></a> 设置当定时器计数为0时是否更新死区时间</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N23mcpwm_operator_config_t23update_dead_time_on_tepE"><code>mcpwm_operator_config_t::update_dead_time_on_tep</code></a> 设置当计时器获取同步信号时是否更新死区时间</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N23mcpwm_operator_config_t24update_dead_time_on_syncE"><code>mcpwm_operator_config_t::update_dead_time_on_sync</code></a> 设置当计时器获取同步信号时是否更新死区时间</li></ul><p><code>mcpwm_new_timer()</code>当成功时函数将会返回一个指向操作器对象的指针。否则他会返回错误代码。特别地，当没有更多空闲操作器资源时，这个函数将会返回<code>ESP_ERR_NOT_FOUND</code>错误。</p><p>相反，使用<code>mcpwm_del_operator()</code>函数将会释放分配的操作器对象。</p><h3 id="MCPWM比较器"><a href="#MCPWM比较器" class="headerlink" title="MCPWM比较器"></a>MCPWM比较器</h3><p>函数：<code>mcpwm_new_comparator()</code></p><p>结构体:<code>mcpwm_comparator_config_t</code></p><p>结构体参数：</p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N25mcpwm_comparator_config_t13intr_priorityE"><code>mcpwm_comparator_config_t::intr_priority</code></a> 设置中断优先级</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N25mcpwm_comparator_config_t17update_cmp_on_tezE"><code>mcpwm_comparator_config_t::update_cmp_on_tez</code></a> 设置当定时器计数为0时，是否更新比较器阈值</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N25mcpwm_comparator_config_t17update_cmp_on_tepE"><code>mcpwm_comparator_config_t::update_cmp_on_tep</code></a> 设置当定时器计数为上限时，是否更新比较器阈值</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N25mcpwm_comparator_config_t18update_cmp_on_syncE"><code>mcpwm_comparator_config_t::update_cmp_on_sync</code></a> 设置当计时器获取同步信号时是否更新比较器阈值</li></ul><p>函数返回值：</p><ul><li><p>成功：指向比较器对象的指针</p></li><li><p>缺少资源：返回<code>ESP_ERR_NOT_FOUND</code></p></li></ul><p>释放对象：</p><p><code>mcpwm_del_comparator()</code></p><h3 id="MCPWM生成器"><a href="#MCPWM生成器" class="headerlink" title="MCPWM生成器"></a>MCPWM生成器</h3><p>函数：<code>mcpwm_new_generator()</code></p><p>操作器句柄：由上一步中<code>mcpwm_new_operator()</code>生成</p><p>结构体:<code>mcpwm_generator_config_t</code></p><p>结构体参数：</p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N24mcpwm_generator_config_t12gen_gpio_numE"><code>mcpwm_generator_config_t::gen_gpio_num</code></a> 设置输出引脚的GPIO号<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N24mcpwm_generator_config_t10invert_pwmE"><code>mcpwm_generator_config_t::invert_pwm</code></a> 设置是否反转PWM信号</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N24mcpwm_generator_config_t12io_loop_backE"><code>mcpwm_generator_config_t::io_loop_back</code></a> 设置是否使能回环模式。该模式用于调试。它会通过GPIO矩阵外设同时使能GPIO的输入和输出</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N24mcpwm_generator_config_t10io_od_modeE"><code>mcpwm_generator_config_t::io_od_mode</code></a> 配置PWM的GPIO为开漏模式</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N24mcpwm_generator_config_t7pull_upE"><code>mcpwm_generator_config_t::pull_up</code></a> 和<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N24mcpwm_generator_config_t9pull_downE"><code>mcpwm_generator_config_t::pull_down</code></a> 控制是否使能内部上拉或下拉</li></ul><p>函数返回值：</p><ul><li><p>成功：指向生成器对象的指针</p></li><li><p>缺少资源：返回<code>ESP_ERR_NOT_FOUND</code></p></li></ul><p>释放对象：</p><p><code>mcpwm_del_generator()</code></p><h3 id="MCPWM故障"><a href="#MCPWM故障" class="headerlink" title="MCPWM故障"></a>MCPWM故障</h3><p>有两类故障：从GPIO反馈的故障，软件生成的故障。</p><h4 id="GPIO故障"><a href="#GPIO故障" class="headerlink" title="GPIO故障"></a>GPIO故障</h4><p>GPIO故障函数：<code>mcpwm_new_gpio_fault()</code>函数</p><p>GPIO故障结构体：<code>mcpwm_gpio_fault_config_t</code></p><p>GPIO故障结构体参数：</p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N25mcpwm_gpio_fault_config_t8group_idE"><code>mcpwm_gpio_fault_config_t::group_id</code></a> 设置MCPWM组ID。注意：由组0的GPIO故障不能被组1的操作器检测到</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N25mcpwm_gpio_fault_config_t13intr_priorityE"><code>mcpwm_gpio_fault_config_t::intr_priority</code></a> 设置中断优先级</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N25mcpwm_gpio_fault_config_t8gpio_numE"><code>mcpwm_gpio_fault_config_t::gpio_num</code></a> 设置故障反馈的GPIO号</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N25mcpwm_gpio_fault_config_t12active_levelE"><code>mcpwm_gpio_fault_config_t::active_level</code></a> 设置故障信号的触发电平</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N25mcpwm_gpio_fault_config_t7pull_upE"><code>mcpwm_gpio_fault_config_t::pull_up</code></a> 和<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N25mcpwm_gpio_fault_config_t9pull_downE"><code>mcpwm_gpio_fault_config_t::pull_down</code></a> 设置GPIO引脚是否上拉/下拉</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N25mcpwm_gpio_fault_config_t12io_loop_backE"><code>mcpwm_gpio_fault_config_t::io_loop_back</code></a> 设置是否使能回环模式（用于调试）</li></ul><p>函数返回值：</p><ul><li><p>成功：指向GPIO故障对象的指针</p></li><li><p>缺少资源：返回<code>ESP_ERR_NOT_FOUND</code></p></li></ul><h4 id="软件故障"><a href="#软件故障" class="headerlink" title="软件故障"></a>软件故障</h4><p>软件故障与等待实际故障信号的GPIO故障不同，它可以被<code>mcpwm_soft_fault_acitvate()</code>函数触发</p><p>软件故障函数：<code>mcpwm_new_soft_fault()</code>函数</p><p>软件故障结构体：<code>mcpwm_soft_fault_config_t</code></p><p>这个配置结构被暂留用于未来用途。</p><p>函数返回值：</p><ul><li><p>成功：指向GPIO故障对象的指针</p></li><li><p>缺少存储资源：返回<code>ESP_ERR_NOT_MEM</code></p></li></ul><p>释放对象：</p><p>两种对象都可以使用同一函数释放：<code>mcpwm_del_fault()</code></p><h3 id="MCPWM同步源"><a href="#MCPWM同步源" class="headerlink" title="MCPWM同步源"></a>MCPWM同步源</h3><p>同步源可以同步MCPWM定时器和MCPWM捕获定时器。有三种同步源：</p><ul><li>从GPIO获取的同步源</li><li>由软件生成的同步源</li><li>由MCPWM定时器事件生成的同步源</li></ul><h4 id="GPIO同步源"><a href="#GPIO同步源" class="headerlink" title="GPIO同步源"></a>GPIO同步源</h4><p>函数：<code>mcpwm_new_gpio_sync_src()</code></p><p>结构体：<code>mcpwm_gpio_sync_src_config_t</code></p><p>结构体参数：</p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N28mcpwm_gpio_sync_src_config_t8group_idE"><code>mcpwm_gpio_sync_src_config_t::group_id</code></a> 设置MCPWM组ID</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N28mcpwm_gpio_sync_src_config_t8gpio_numE"><code>mcpwm_gpio_sync_src_config_t::gpio_num</code></a> 设置同步源使用的GPIO号</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N28mcpwm_gpio_sync_src_config_t10active_negE"><code>mcpwm_gpio_sync_src_config_t::active_neg</code></a> 设置是否下降沿触发同步信号+</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N28mcpwm_gpio_sync_src_config_t7pull_upE"><code>mcpwm_gpio_sync_src_config_t::pull_up</code></a> 和<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N28mcpwm_gpio_sync_src_config_t9pull_downE"><code>mcpwm_gpio_sync_src_config_t::pull_down</code></a> 设置GPIO引脚是否上拉/下拉</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N28mcpwm_gpio_sync_src_config_t12io_loop_backE"><code>mcpwm_gpio_sync_src_config_t::io_loop_back</code></a> 设置是否使能回环模式（用于调试）</li></ul><p>函数返回值：</p><ul><li>成功：指向同步源对象的指针</li><li>没有空闲GPIO同步源：返回<code>ESP_ERR_NOT_FOUND</code></li></ul><h4 id="定时器同步源"><a href="#定时器同步源" class="headerlink" title="定时器同步源"></a>定时器同步源</h4><p>函数：<code>mcpwm_new_timer_sync_src()</code></p><p>结构体：<code>mcpwm_timer_sync_src_config_t</code></p><p>结构体参数：</p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N29mcpwm_timer_sync_src_config_t11timer_eventE"><code>mcpwm_timer_sync_src_config_t::timer_event</code></a> 配置生成同步信号的定时器事件</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N29mcpwm_timer_sync_src_config_t20propagate_input_syncE"><code>mcpwm_timer_sync_src_config_t::propagate_input_sync</code></a> 设置是否传播输入同步信号（输入同步信号将会被连接到输出）</li></ul><p>函数返回值：</p><ul><li>成功：指向同步源对象的指针</li><li>同步源已经被同一定时器分配：返回<code>ESP_ERR_INVALID_STATE</code></li></ul><h4 id="软件同步源"><a href="#软件同步源" class="headerlink" title="软件同步源"></a>软件同步源</h4><p>触发方法：<code>mcpwm_soft_sync_activate()</code></p><p>函数：<code>mcpwm_new_soft_sync_src()</code></p><p>结构体：<code>mcpwm_soft_sync_src_config_t</code></p><p>这个配置结构被暂留用于未来用途。</p><p>函数返回值：</p><ul><li>成功：指向同步源对象的指针</li><li>同步源已经被同一定时器分配：返回<code>ESP_ERR_INVALID_STATE</code></li></ul><p>释放对象：</p><p>三种对象都可以使用同一函数释放：<code>mcpwm_del_fault()</code></p><h3 id="MCPWM捕获定时器和通道"><a href="#MCPWM捕获定时器和通道" class="headerlink" title="MCPWM捕获定时器和通道"></a>MCPWM捕获定时器和通道</h3><p>MCPWM有一个专用的捕获定时器用于在特定事件发生时捕获时间戳。捕获定时器连接由数个独立的通道，每个通道分配有GPIO。</p><h4 id="捕获定时器"><a href="#捕获定时器" class="headerlink" title="捕获定时器"></a>捕获定时器</h4><p>函数：<code>mcpwm_new_capture_timer()</code></p><p>结构体：<code>mvpwm_capture_timer_config_t</code></p><p>结构体参数：</p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N28mcpwm_capture_timer_config_t8group_idE"><code>mcpwm_capture_timer_config_t::group_id</code></a> 设置MCPWM组ID</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N28mcpwm_capture_timer_config_t7clk_srcE"><code>mcpwm_capture_timer_config_t::clk_src</code></a> 设置捕获定时器的时钟源</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N28mcpwm_capture_timer_config_t13resolution_hzE"><code>mcpwm_capture_timer_config_t::resolution_hz</code></a> 将会基于时钟源和分辨率内部设置合适的分频器。如果设置为0，系统将会选择一个合适的分辨率，可以同过函数<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv434mcpwm_capture_timer_get_resolution24mcpwm_cap_timer_handle_tP8uint32_t"><code>mcpwm_capture_timer_get_resolution()</code></a> 来查看当前定时器分辨率</li></ul><p><strong>备注：ESP32S3中，<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N28mcpwm_capture_timer_config_t13resolution_hzE"><code>mcpwm_capture_timer_config_t::resolution_hz</code></a> 无法使用，捕获定时器的分辨率永远等于<code>MCPWM_CAPTURE_CLK_SRC_APB</code></strong></p><p>函数返回值：</p><ul><li>成功：指向定时器对象的指针</li><li>MCPWM组内无空闲捕获定时器：返回<code>ESP_ERR_NOT_FOUND</code></li></ul><h4 id="捕获通道"><a href="#捕获通道" class="headerlink" title="捕获通道"></a>捕获通道</h4><p>函数：<code>mcpwm_new_capture_channel()</code></p><p>结构体：<code>mvpwm_capture_channel_config_t</code></p><p>结构体参数：</p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N30mcpwm_capture_channel_config_t13intr_priorityE"><code>mcpwm_capture_channel_config_t::intr_priority</code></a> 设置中断优先级</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N30mcpwm_capture_channel_config_t8gpio_numE"><code>mcpwm_capture_channel_config_t::gpio_num</code></a> 设置捕获通道使用的GPIO号</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N30mcpwm_capture_channel_config_t8prescaleE"><code>mcpwm_capture_channel_config_t::prescale</code></a> 设置输入信号的预分频器</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N30mcpwm_capture_channel_config_t8pos_edgeE"><code>mcpwm_capture_channel_config_t::pos_edge</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N30mcpwm_capture_channel_config_t8neg_edgeE"><code>mcpwm_capture_channel_config_t::neg_edge</code></a> 设置捕获方式为：上升沿/下降沿</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N30mcpwm_capture_channel_config_t7pull_upE"><code>mcpwm_capture_channel_config_t::pull_up</code></a> 和<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N30mcpwm_capture_channel_config_t9pull_downE"><code>mcpwm_capture_channel_config_t::pull_down</code></a> 设置是否上拉/下拉GPIO</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N30mcpwm_capture_channel_config_t17invert_cap_signalE"><code>mcpwm_capture_channel_config_t::invert_cap_signal</code></a> 设置是否反转捕获信号</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N30mcpwm_capture_channel_config_t12io_loop_backE"><code>mcpwm_capture_channel_config_t::io_loop_back</code></a> 设置是否使能回环模式（用于调试）</li></ul><p>函数返回值：</p><ul><li>成功：指向捕获通道对象的指针</li><li>捕获定时器内无空闲捕获通道：返回<code>ESP_ERR_NOT_FOUND</code></li></ul><p>释放：</p><p><code>mcpwm_del_capture_channel()</code>和<code>mcpwm_del_capture_timer()</code></p><h3 id="MCPWM中断优先级"><a href="#MCPWM中断优先级" class="headerlink" title="MCPWM中断优先级"></a>MCPWM中断优先级</h3><p>MCPWM允许分别配置不同定时器、操作器、比较器、捕获时间的中断。中断优先级取决于各自结构体中<code>intr_priority</code>参数。另外，同一个MCPWM组的事件共享同一个中断源。当注册多个中断事件时，中断优先级需要保持一致。</p><p><strong>在MCPWM组内注册多个中断事件时，驱动器将使用第一个注册事件的中断优先级作为MCPWM组的中断优先级。</strong></p><h2 id="定时器操作和事件"><a href="#定时器操作和事件" class="headerlink" title="定时器操作和事件"></a>定时器操作和事件</h2><h3 id="注册事件回调函数"><a href="#注册事件回调函数" class="headerlink" title="注册事件回调函数"></a>注册事件回调函数</h3><p>MCPWM定时器在运行的过程中可以生成不同的事件。通过<code>mcpwm_timer_register_event_callbacks()</code>连接函数与中断服务路径可以在特定事件发生时调用回调函数。</p><p>回调函数的原型在<code>mcpwm_timer_event_cb_t</code>中声明</p><p>所有支持的事件回调在<code>mcpwm_timer_event_callbacks_t</code>中声明:</p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N29mcpwm_timer_event_callbacks_t7on_fullE"><code>mcpwm_timer_event_callbacks_t::on_full</code></a> 当计时器达到上限时，设置回调函数</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N29mcpwm_timer_event_callbacks_t8on_emptyE"><code>mcpwm_timer_event_callbacks_t::on_empty</code></a> 当计时器为空时（计数器=0），设置回调函数</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N29mcpwm_timer_event_callbacks_t7on_stopE"><code>mcpwm_timer_event_callbacks_t::on_stop</code></a> 当定时器停止时，设置回调函数</li></ul><p>上面的回调函数是在ISR上下文中调用的，因此它们不应试图阻塞（例如，确保函数中只调用带有ISR后缀的FreeRTOS API）。</p><p><code>mcpwm_timer_register_event_callbacks()</code>函数的 <code>user_data</code> 参数用于保存用户定义的内容，他将会直接传到回调函数中。</p><p>此功能将在不启用MCPWM定时器的情况下延迟安装中断服务。需要在<code>mcpwm_timer_enable()</code>之前配置好回调函数，否则会返回<code>ESP_ERR_INVALID_STATE</code>错误</p><h3 id="使能和失能定时器"><a href="#使能和失能定时器" class="headerlink" title="使能和失能定时器"></a>使能和失能定时器</h3><p>在控制定时器IO控制之前，用户需要通过<code>mcpwm_timer_enable()</code>使能定时器。这个函数的功能为：</p><ul><li>切换定时器状态从初始化到使能</li><li>使能中断服务（如果中断服务被<code>mcpwm_timer_register_event_callbacks()</code>延迟启动的话）</li><li>获取合适功率管理锁（如果选用特殊的时钟源，入PLL_160M时钟）</li></ul><p>相反，使用<code>mcpwm_timer_disable()</code>来使定时器回到初始状态，失能定时器中断服务并释放电源管理锁。</p><h3 id="开启和停止时钟"><a href="#开启和停止时钟" class="headerlink" title="开启和停止时钟"></a>开启和停止时钟</h3><p>定时器的基本IO操作是开启和停止。通过函数<code>mcpwm_timer_start_stop()</code>和不同的<code>mcpwm_timer_start_stop_cmd_t</code>结构体命令可以立即开始定时器或在特定事件停止定时器。并且你可以仅开始一圈定时（在计数达到峰值/清空时停止他自己）</p><h3 id="连接定时器与操作器"><a href="#连接定时器与操作器" class="headerlink" title="连接定时器与操作器"></a>连接定时器与操作器</h3><p>MCPWM定时器应该通过<code>mcpwm_operatr_connect_timer()</code>连接MCPWM操作器。此后操作器才能将定时器作为自己的时基，并且生成需要的PWM波。确保MCPWM定时器和操作器在同一个组内，否则函数将会返回<code>ESP_ERR_INVALID_ARG</code>错误</p><h2 id="比较器动作与事件"><a href="#比较器动作与事件" class="headerlink" title="比较器动作与事件"></a>比较器动作与事件</h2><h3 id="注册事件回调函数-1"><a href="#注册事件回调函数-1" class="headerlink" title="注册事件回调函数"></a>注册事件回调函数</h3><p>MCPWM比较器可以在定时计数器达到比较阈值时以中断的形式通知用户。如果当事件发生时，你有一些函数需要被调用，你应该通过<code>mcpwm_comparator_register_event_callbacks()</code>链接你的函数到中断服务路径。回调函数原型为<code>mcpwm_compare_event_cb_t()</code>。所有支持的回调列在<code>mcpwm_comparator_event_callbacks_t</code>结构体中：</p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N34mcpwm_comparator_event_callbacks_t8on_reachE"><code>mcpwm_comparator_event_callbacks_t::on_reach</code></a> 设置当计时器达到比较阈值时的回调函数</li></ul><p>回调函数会提供<code>mcpwm_compare_event_data_t</code>类型的事件详细信息。回调函数在ISR上下文中调用，因此它不应该尝试去阻滞（确定只有带ISR的FreeRTOS API在函数中调用）</p><p><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv441mcpwm_comparator_register_event_callbacks19mcpwm_cmpr_handle_tPK34mcpwm_comparator_event_callbacks_tPv"><code>mcpwm_comparator_register_event_callbacks()</code></a> 中的<code>user_data</code> 用于保存用户自定义内容，这个参数将会直接传给回调函数</p><p>这个函数将会延迟比较器中断服务，而服务将会在<code>mcpwm_del_compaarator</code>中删除</p><h3 id="设置比较阈值"><a href="#设置比较阈值" class="headerlink" title="设置比较阈值"></a>设置比较阈值</h3><p>允许在比较器运行过程中修改</p><p>函数：<code>mcpwm_comparator_set_compare_value()</code></p><ul><li>新比较值不会立即作用，更新时刻由<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N25mcpwm_comparator_config_t17update_cmp_on_tezE"><code>mcpwm_comparator_config_t::update_cmp_on_tez</code></a> or <a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N25mcpwm_comparator_config_t17update_cmp_on_tepE"><code>mcpwm_comparator_config_t::update_cmp_on_tep</code></a> or <a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N25mcpwm_comparator_config_t18update_cmp_on_syncE"><code>mcpwm_comparator_config_t::update_cmp_on_sync</code></a>控制</li><li>确保操作器已经连接到MCPWM定时器上，否则将会返回<code>ESP_ERR_INVALID_STATE</code>错误</li><li>比较阈值不应该超过计数器的峰值，否则比较事件永远不会触发</li></ul><h2 id="生成器动作与事件"><a href="#生成器动作与事件" class="headerlink" title="生成器动作与事件"></a>生成器动作与事件</h2><h3 id="在定时器事件中设定生成器动作"><a href="#在定时器事件中设定生成器动作" class="headerlink" title="在定时器事件中设定生成器动作"></a>在定时器事件中设定生成器动作</h3><p>一个生成器可以在不同定时器事件中设定不同的动作。</p><p>设定函数：<code>mcpwm_generator_set_actions_on_timer_event()</code></p><p>配置结构体：<code>mcpwm_gen_timer_event_action_t</code></p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N30mcpwm_gen_timer_event_action_t9directionE"><code>mcpwm_gen_timer_event_action_t::direction</code></a> 配置定时器方向。可选方向定义在<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv423mcpwm_timer_direction_t"><code>mcpwm_timer_direction_t</code></a>中</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N30mcpwm_gen_timer_event_action_t5eventE"><code>mcpwm_gen_timer_event_action_t::event</code></a> 配置定时器事件。支持的事件种类定义在 <a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv419mcpwm_timer_event_t"><code>mcpwm_timer_event_t</code></a>中</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N30mcpwm_gen_timer_event_action_t6actionE"><code>mcpwm_gen_timer_event_action_t::action</code></a> 配置生成器动作。支持的动作定义在 <a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv424mcpwm_generator_action_t"><code>mcpwm_generator_action_t</code></a>中</li></ul><p>宏定义<code>MCPWM_GENT_TIMER_EVENT_ACTION</code>用于简化定时器动作整体的结构。</p><p>注意：<code>mcpwm_generator_set_actions_on_timer_event()</code>的参数列表应该以<code>MCPWM_GEN_TIMER_EVENT_ACTION_END</code>结尾。</p><p>也可以逐个定时定时器动作，通过<code>mcpwm_generator_set_action_on_timer_event()</code>（无可变参数）</p><h3 id="在比较器事件中设定生成器动作"><a href="#在比较器事件中设定生成器动作" class="headerlink" title="在比较器事件中设定生成器动作"></a>在比较器事件中设定生成器动作</h3><p>设定函数：<code>mcpwm_generator_set_actions_on_compare_event()</code></p><p>配置结构体：<code>mcpwm_gen_compare_event_action_t</code></p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N32mcpwm_gen_compare_event_action_t9directionE"><code>mcpwm_gen_compare_event_action_t::direction</code></a> 配置定时器方向。可选方向定义在<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv423mcpwm_timer_direction_t"><code>mcpwm_timer_direction_t</code></a>中</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N32mcpwm_gen_compare_event_action_t10comparatorE"><code>mcpwm_gen_compare_event_action_t::comparator</code></a> 配置比较器处理句柄specifies the comparator handle. 查阅<a class="link" target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#mcpwm-comparators">MCPWM Comparators <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 中分配比较器的方法</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N32mcpwm_gen_compare_event_action_t6actionE"><code>mcpwm_gen_compare_event_action_t::action</code></a> 配置生成器动作。支持的动作定义在 <a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv424mcpwm_generator_action_t"><code>mcpwm_generator_action_t</code></a>中</li></ul><p>有一个辅助宏MCPWM_GEN_COMPARE_EVENT_ACTION，用于简化比较事件操作项的结构。</p><p>注意：<code>mcpwm_generator_set_actions_on_compare_event()</code>的参数列表应该以<code>MCPWM_GEN_COMPARE_EVENT_ACTION_END</code>结尾。</p><p>也可以逐个定时定时器动作，通过<code>mcpwm_generator_set_action_on_compare_event()</code>（无可变参数）</p><h2 id="经典PWM波和生成器配置"><a href="#经典PWM波和生成器配置" class="headerlink" title="经典PWM波和生成器配置"></a>经典PWM波和生成器配置</h2><p>这一章节中，将会解释生成器可以生成的经典的PWM波形。波形下面为代码片段。章节主要分为：</p><ul><li>波形的对称与非对称由MCPWM定时器的计数模式决定</li><li>波形对的有效电平由具有较小占空比的PWM的电平决定</li><li>PWM波的周期由定时器周期和计数模式决定</li><li>PWM波占空比由生成器的不同动作综合决定</li></ul><h3 id="单边非对称波形（有效电平：高）"><a href="#单边非对称波形（有效电平：高）" class="headerlink" title="单边非对称波形（有效电平：高）"></a>单边非对称波形（有效电平：高）</h3><p>![](E:\0_VS\6_Blog\chepeys_blog\source_posts\嵌入式\ESP32S3\外设API\4 电机控制PWM\wavedrom.svg)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
{
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(gena,
                    MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(gena,
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_LOW)));
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(genb,
                    MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(genb,
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpb, MCPWM_GEN_ACTION_LOW)));
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单边非对称波形（有效电平：低）"><a href="#单边非对称波形（有效电平：低）" class="headerlink" title="单边非对称波形（有效电平：低）"></a>单边非对称波形（有效电平：低）</h3><p>![](E:\0_VS\6_Blog\chepeys_blog\source_posts\嵌入式\ESP32S3\外设API\4 电机控制PWM\wavedrom1.svg)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
{
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(gena,
                    MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_FULL, MCPWM_GEN_ACTION_LOW)));
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(gena,
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_HIGH)));
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(genb,
                    MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_FULL, MCPWM_GEN_ACTION_LOW)));
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(genb,
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpb, MCPWM_GEN_ACTION_HIGH)));
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="非对称脉冲放置"><a href="#非对称脉冲放置" class="headerlink" title="非对称脉冲放置"></a>非对称脉冲放置</h3><p>![image-20240131161204114](E:\0_VS\6_Blog\chepeys_blog\source_posts\嵌入式\ESP32S3\外设API\4 电机控制PWM\image-20240131161204114.png)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
{
    ESP_ERROR_CHECK(mcpwm_generator_set_actions_on_compare_event(gena,
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_HIGH),
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpb, MCPWM_GEN_ACTION_LOW),
                    MCPWM_GEN_COMPARE_EVENT_ACTION_END()));
    ESP_ERROR_CHECK(mcpwm_generator_set_actions_on_timer_event(genb,
                    MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_TOGGLE),
                    MCPWM_GEN_TIMER_EVENT_ACTION_END()));
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双边非对称波形（有效电平：低）"><a href="#双边非对称波形（有效电平：低）" class="headerlink" title="双边非对称波形（有效电平：低）"></a>双边非对称波形（有效电平：低）</h3><p>![wavedrom3](E:\0_VS\6_Blog\chepeys_blog\source_posts\嵌入式\ESP32S3\外设API\4 电机控制PWM\wavedrom3.svg)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
{
    ESP_ERROR_CHECK(mcpwm_generator_set_actions_on_compare_event(gena,
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_HIGH),
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_DOWN, cmpb, MCPWM_GEN_ACTION_LOW),
                    MCPWM_GEN_COMPARE_EVENT_ACTION_END()));
    ESP_ERROR_CHECK(mcpwm_generator_set_actions_on_timer_event(genb,
                    MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_LOW),
                    MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_DOWN, MCPWM_TIMER_EVENT_FULL, MCPWM_GEN_ACTION_HIGH),
                    MCPWM_GEN_TIMER_EVENT_ACTION_END()));
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双边对称波形（有效电平：低）"><a href="#双边对称波形（有效电平：低）" class="headerlink" title="双边对称波形（有效电平：低）"></a>双边对称波形（有效电平：低）</h3><p>![wavedrom5](E:\0_VS\6_Blog\chepeys_blog\source_posts\嵌入式\ESP32S3\外设API\4 电机控制PWM\wavedrom5.svg)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
{
    ESP_ERROR_CHECK(mcpwm_generator_set_actions_on_compare_event(gena,
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_HIGH),
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_DOWN, cmpb, MCPWM_GEN_ACTION_LOW),
                    MCPWM_GEN_COMPARE_EVENT_ACTION_END()));
    ESP_ERROR_CHECK(mcpwm_generator_set_actions_on_timer_event(genb,
                    MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_LOW),
                    MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_DOWN, MCPWM_TIMER_EVENT_FULL, MCPWM_GEN_ACTION_HIGH),
                    MCPWM_GEN_TIMER_EVENT_ACTION_END()));
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="双边对称波形（互补）"><a href="#双边对称波形（互补）" class="headerlink" title="双边对称波形（互补）"></a>双边对称波形（互补）</h3><p>![wavedrom6](E:\0_VS\6_Blog\chepeys_blog\source_posts\嵌入式\ESP32S3\外设API\4 电机控制PWM\wavedrom6.svg)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
{
    ESP_ERROR_CHECK(mcpwm_generator_set_actions_on_compare_event(gena,
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_HIGH),
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_DOWN, cmpa, MCPWM_GEN_ACTION_LOW),
                    MCPWM_GEN_COMPARE_EVENT_ACTION_END()));
    ESP_ERROR_CHECK(mcpwm_generator_set_actions_on_compare_event(genb,
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpb, MCPWM_GEN_ACTION_LOW),
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_DOWN, cmpb, MCPWM_GEN_ACTION_HIGH),
                    MCPWM_GEN_COMPARE_EVENT_ACTION_END()));
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="死区时间"><a href="#死区时间" class="headerlink" title="死区时间"></a>死区时间</h2><p>在电力电子中，常常使用整流器和逆变器。其中会用到整流桥和逆变桥。这些桥的每一边都有两个电子元件（如：MOS管、IGBT管）。同一臂的两个MOS管不能在同一时间导通，否则将会造成短路。事实上，尽管PWM波看上去是陡降的，但实际上MOS管也需要时间去关闭/打开。这就需要向已有PWM波加入额外的延迟——死区时间。</p><p>死区时间驱动的工作类似一个解码器，这一特点体现在<code>mcpwm_generator_set_dead_time()</code>的参数中。这个函数输入一个前一级生成器的句柄（<code>in_generator</code>）在加入死区时间后输出一个新生成器句柄（<code>out_generator</code>）。注意，如果<code>out_generator</code>与<code>in_generator</code>相同，则代表我们正在以“原位”的方式将时间延迟添加到PWM波形中。相反，如果<code>out_generator</code>与<code>in_generator</code>不同，这意味着我们正在从旧的<code>in_generator</code>中导出一个新的PWM波形。</p><p>实例化结构体<code>mcpwm_dead_time_config_t</code>：</p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N24mcpwm_dead_time_config_t19posedge_delay_ticksE"><code>mcpwm_dead_time_config_t::posedge_delay_ticks</code></a> 和 <a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N24mcpwm_dead_time_config_t19negedge_delay_ticksE"><code>mcpwm_dead_time_config_t::negedge_delay_ticks</code></a> 设置在上升沿和下降沿加入延迟的数量。特别地，设置两个都为0意味着跳过死区生成模块。死区嘀嗒的分辨率接入的操作器定时器相同</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N24mcpwm_dead_time_config_t13invert_outputE"><code>mcpwm_dead_time_config_t::invert_output</code></a>: 应用死区时间后，是否对信号反转，可用于控制延迟边缘极性。</li></ul><h3 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h3><p>由于硬件限制，一个延迟模块（上升沿延迟或下降沿延迟）不能同时应用给多个MCPWM生成器。</p><p>然而，可以让下降沿延迟给生成器A，上升沿延迟给生成器B。也可以给生成器同时设置上升沿、下降沿延迟，让生成器B跳过死区时间模块。</p><h2 id="经典PWM波和死区时间配置"><a href="#经典PWM波和死区时间配置" class="headerlink" title="经典PWM波和死区时间配置"></a>经典PWM波和死区时间配置</h2><p>本小节讲解可以由死区时间模块生成的经典PWM波形。</p><h3 id="高电平有效、互补"><a href="#高电平有效、互补" class="headerlink" title="高电平有效、互补"></a>高电平有效、互补</h3><p>![wavedrom7](E:\0_VS\6_Blog\chepeys_blog\source_posts\嵌入式\ESP32S3\外设API\4 电机控制PWM\wavedrom7.svg)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
{
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(gena,
                    MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(gena,
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_LOW)));
}

static void dead_time_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb)
{
    mcpwm_dead_time_config_t dead_time_config = {
        .posedge_delay_ticks = 50,
        .negedge_delay_ticks = 0
    };
    ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(gena, gena, &amp;dead_time_config));
    dead_time_config.posedge_delay_ticks = 0;
    dead_time_config.negedge_delay_ticks = 100;
    dead_time_config.flags.invert_output = true;
    ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(gena, genb, &amp;dead_time_config));
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="低电平有效、互补"><a href="#低电平有效、互补" class="headerlink" title="低电平有效、互补"></a>低电平有效、互补</h3><p>![wavedrom8](E:\0_VS\6_Blog\chepeys_blog\source_posts\嵌入式\ESP32S3\外设API\4 电机控制PWM\wavedrom8.svg)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
{
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(gena,
                    MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(gena,
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_LOW)));
}

static void dead_time_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb)
{
    mcpwm_dead_time_config_t dead_time_config = {
        .posedge_delay_ticks = 50,
        .negedge_delay_ticks = 0,
        .flags.invert_output = true
    };
    ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(gena, gena, &amp;dead_time_config));
    dead_time_config.posedge_delay_ticks = 0;
    dead_time_config.negedge_delay_ticks = 100;
    dead_time_config.flags.invert_output = false;
    ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(gena, genb, &amp;dead_time_config));
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高电平有效"><a href="#高电平有效" class="headerlink" title="高电平有效"></a>高电平有效</h3><p>![wavedrom9](E:\0_VS\6_Blog\chepeys_blog\source_posts\嵌入式\ESP32S3\外设API\4 电机控制PWM\wavedrom9.svg)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
{
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(gena,
                    MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(gena,
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_LOW)));
}

static void dead_time_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb)
{
    mcpwm_dead_time_config_t dead_time_config = {
        .posedge_delay_ticks = 50,
        .negedge_delay_ticks = 0,
    };
    ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(gena, gena, &amp;dead_time_config));
    dead_time_config.posedge_delay_ticks = 0;
    dead_time_config.negedge_delay_ticks = 100;
    ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(gena, genb, &amp;dead_time_config));
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="低电平有效"><a href="#低电平有效" class="headerlink" title="低电平有效"></a>低电平有效</h3><p>![wavedrom10](E:\0_VS\6_Blog\chepeys_blog\source_posts\嵌入式\ESP32S3\外设API\4 电机控制PWM\wavedrom10.svg)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
{
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(gena,
                    MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(gena,
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_LOW)));
}

static void dead_time_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb)
{
    mcpwm_dead_time_config_t dead_time_config = {
        .posedge_delay_ticks = 50,
        .negedge_delay_ticks = 0,
        .flags.invert_output = true
    };
    ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(gena, gena, &amp;dead_time_config));
    dead_time_config.posedge_delay_ticks = 0;
    dead_time_config.negedge_delay_ticks = 100;
    ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(gena, genb, &amp;dead_time_config));
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="上升沿延迟，PWMB跳过"><a href="#上升沿延迟，PWMB跳过" class="headerlink" title="上升沿延迟，PWMB跳过"></a>上升沿延迟，PWMB跳过</h3><p>![image-20240131172826696](E:\0_VS\6_Blog\chepeys_blog\source_posts\嵌入式\ESP32S3\外设API\4 电机控制PWM\wavedrom11.png)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
{
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(gena,
                    MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(gena,
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_LOW)));
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(genb,
                    MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(genb,
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpb, MCPWM_GEN_ACTION_LOW)));
}

static void dead_time_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb)
{
    mcpwm_dead_time_config_t dead_time_config = {
        .posedge_delay_ticks = 50,
        .negedge_delay_ticks = 0,
    };
    // apply deadtime to generator_a
    ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(gena, gena, &amp;dead_time_config));
    // bypass deadtime module for generator_b
    dead_time_config.posedge_delay_ticks = 0;
    ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(genb, genb, &amp;dead_time_config));
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="PWMB下降沿延迟，PWMA跳过"><a href="#PWMB下降沿延迟，PWMA跳过" class="headerlink" title="PWMB下降沿延迟，PWMA跳过"></a>PWMB下降沿延迟，PWMA跳过</h3><p>![image-20240131172958261](E:\0_VS\6_Blog\chepeys_blog\source_posts\嵌入式\ESP32S3\外设API\4 电机控制PWM\image-20240131172958261.png)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
{
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(gena,
                    MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(gena,
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_LOW)));
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(genb,
                    MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(genb,
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpb, MCPWM_GEN_ACTION_LOW)));
}

static void dead_time_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb)
{
    mcpwm_dead_time_config_t dead_time_config = {
        .posedge_delay_ticks = 0,
        .negedge_delay_ticks = 0,
    };
    // generator_a bypass the deadtime module (no delay)
    ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(gena, gena, &amp;dead_time_config));
    // apply dead time to generator_b
    dead_time_config.negedge_delay_ticks = 50;
    ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(genb, genb, &amp;dead_time_config));

}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="PWMB上升沿、下降沿延迟，PWMA跳过"><a href="#PWMB上升沿、下降沿延迟，PWMA跳过" class="headerlink" title="PWMB上升沿、下降沿延迟，PWMA跳过"></a>PWMB上升沿、下降沿延迟，PWMA跳过</h3><p>![image-20240131173058139](E:\0_VS\6_Blog\chepeys_blog\source_posts\嵌入式\ESP32S3\外设API\4 电机控制PWM\image-20240131173058139.png)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static void gen_action_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb, mcpwm_cmpr_handle_t cmpa, mcpwm_cmpr_handle_t cmpb)
{
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(gena,
                    MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(gena,
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpa, MCPWM_GEN_ACTION_LOW)));
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_timer_event(genb,
                    MCPWM_GEN_TIMER_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, MCPWM_TIMER_EVENT_EMPTY, MCPWM_GEN_ACTION_HIGH)));
    ESP_ERROR_CHECK(mcpwm_generator_set_action_on_compare_event(genb,
                    MCPWM_GEN_COMPARE_EVENT_ACTION(MCPWM_TIMER_DIRECTION_UP, cmpb, MCPWM_GEN_ACTION_LOW)));
}

static void dead_time_config(mcpwm_gen_handle_t gena, mcpwm_gen_handle_t genb)
{
    mcpwm_dead_time_config_t dead_time_config = {
        .posedge_delay_ticks = 0,
        .negedge_delay_ticks = 0,
    };
    // generator_a bypass the deadtime module (no delay)
    ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(gena, gena, &amp;dead_time_config));
    // apply dead time on both edge for generator_b
    dead_time_config.negedge_delay_ticks = 50;
    dead_time_config.posedge_delay_ticks = 50;
    ESP_ERROR_CHECK(mcpwm_generator_set_dead_time(genb, genb, &amp;dead_time_config));
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="载波调制"><a href="#载波调制" class="headerlink" title="载波调制"></a>载波调制</h2><p>MCPWM操作器有一个载波子模块，如果需要通过变压器传递PWM输出信号与电机驱动器进行电流隔离（例如，隔离的数字电源应用），则可以使用该载波子模块。任何PWM输出信号可能拥有100%占空比，并且每当电机需要稳定在满负载运行时，这个占空比不会改变。</p><p>非交流信号和变压器耦合具有一定的问题，所以载波调制模块用于创造一个交流信号，解决耦合问题。</p><p>函数：<code>mcpwm_operator_apply_carrier()</code></p><p>配置结构体：<code>mcpwm_carrier_config_t</code></p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N22mcpwm_carrier_config_t7clk_srcE"><code>mcpwm_carrier_config_t::clk_src</code></a> 设置载波器的时钟源</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N22mcpwm_carrier_config_t12frequency_hzE"><code>mcpwm_carrier_config_t::frequency_hz</code></a> 代表载波频率（Hz）</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N22mcpwm_carrier_config_t10duty_cycleE"><code>mcpwm_carrier_config_t::duty_cycle</code></a> 代表载波的占空比。注意，支持的周期是离散的，因此驱动器将会搜索与配置值最近的周期</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N22mcpwm_carrier_config_t23first_pulse_duration_usE"><code>mcpwm_carrier_config_t::first_pulse_duration_us</code></a> 代表以微秒为单位的第一个脉冲的长度。第一个脉冲长度的分辨率由载波频率决定。第一个脉冲的长度不能为0，且至少为1个载波的周期。更长的脉冲宽度可以更快传导电感</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N22mcpwm_carrier_config_t22invert_before_modulateE"><code>mcpwm_carrier_config_t::invert_before_modulate</code></a> 和<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N22mcpwm_carrier_config_t21invert_after_modulateE"><code>mcpwm_carrier_config_t::invert_after_modulate</code></a> 设置是否调制后反转载波输出</li></ul><p>载波子模块失能函数：给<code>mcpwm_operator_apply_carrier()</code>NULL配置参数</p><h2 id="故障及刹车动作"><a href="#故障及刹车动作" class="headerlink" title="故障及刹车动作"></a>故障及刹车动作</h2><p>MCPWM操作器能够检测外部电机、电源驱动器或任何外设的故障信号。这些故障信号被压缩进了MCPWM故障对象中。</p><p>用户应该决定可能存在的电机故障模式和解决方案（如：使有刷电机所有输出拉低或锁定步进电机当前的状态等）。这些都解决方法的目的是使电机处于一个安全的状态，减少造成损失的可能性。</p><h3 id="设置故障时操作器刹车模式"><a href="#设置故障时操作器刹车模式" class="headerlink" title="设置故障时操作器刹车模式"></a>设置故障时操作器刹车模式</h3><p>操作器解决错误的过程成为刹车。MCPWM操作器可以配置不同的刹车模式。</p><p>函数：<code>mcpwm_operator_set_brake_on_fault()</code></p><p>结构体：<code>mcpwm_brake_config_t</code></p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N20mcpwm_brake_config_t5faultE"><code>mcpwm_brake_config_t::fault</code></a> 设置故障源</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N20mcpwm_brake_config_t10brake_modeE"><code>mcpwm_brake_config_t::brake_mode</code></a> 设置故障源链接的刹车模式。支持的模式定义在 <a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv427mcpwm_operator_brake_mode_t"><code>mcpwm_operator_brake_mode_t</code></a>.中。<ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N27mcpwm_operator_brake_mode_t25MCPWM_OPER_BRAKE_MODE_CBCE"><code>MCPWM_OPER_BRAKE_MODE_CBC</code></a> ：操作器将会重启 。可以在<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N20mcpwm_brake_config_t18cbc_recover_on_tezE"><code>mcpwm_brake_config_t::cbc_recover_on_tez</code></a> 和<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N20mcpwm_brake_config_t18cbc_recover_on_tepE"><code>mcpwm_brake_config_t::cbc_recover_on_tep</code></a>修改回复时间</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N27mcpwm_operator_brake_mode_t25MCPWM_OPER_BRAKE_MODE_OSTE"><code>MCPWM_OPER_BRAKE_MODE_OST</code></a> ：操作器在遇到错误后不能重启。用户需要使用<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv433mcpwm_operator_recover_from_fault19mcpwm_oper_handle_t20mcpwm_fault_handle_t"><code>mcpwm_operator_recover_from_fault()</code></a>手动重启操作器</li></ul></li></ul><h3 id="设置刹车事件时生成器的动作"><a href="#设置刹车事件时生成器的动作" class="headerlink" title="设置刹车事件时生成器的动作"></a>设置刹车事件时生成器的动作</h3><p>一个生成器可以对不同故障设置多种动作。</p><p>函数：<code>mcpwm_generator_set_actions_on_brake_event()</code></p><p>结构体：<code>mvpwm_gen_brake_event_action_t</code></p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N30mcpwm_gen_brake_event_action_t9directionE"><code>mcpwm_gen_brake_event_action_t::direction</code></a> 修改定时器方向。支持的方向定义在 <a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv423mcpwm_timer_direction_t"><code>mcpwm_timer_direction_t</code></a> 中</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N30mcpwm_gen_brake_event_action_t10brake_modeE"><code>mcpwm_gen_brake_event_action_t::brake_mode</code></a> 修改刹车模式。支持的刹车模式定义在 <a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv427mcpwm_operator_brake_mode_t"><code>mcpwm_operator_brake_mode_t</code></a> 中</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N30mcpwm_gen_brake_event_action_t6actionE"><code>mcpwm_gen_brake_event_action_t::action</code></a> 修改生成器动作。支持的动作列在<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv424mcpwm_generator_action_t"><code>mcpwm_generator_action_t</code></a> 中</li></ul><p>宏定义<code>MCPWM_GEN_BRAKE_EVENT_ACTION</code> 用于简化刹车事件的结构。</p><p>注意，在<code>mcpwm_generator_set_actions_on_brake_event()</code>的参数应该以<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#c.MCPWM_GEN_BRAKE_EVENT_ACTION_END"><code>MCPWM_GEN_BRAKE_EVENT_ACTION_END</code></a> 结尾。</p><p>也可以通过<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv441mcpwm_generator_set_action_on_brake_event18mcpwm_gen_handle_t30mcpwm_gen_brake_event_action_t"><code>mcpwm_generator_set_action_on_brake_event()</code></a>逐个设置制动事件。</p><h3 id="注册故障事件回调"><a href="#注册故障事件回调" class="headerlink" title="注册故障事件回调"></a>注册故障事件回调</h3><p>MCPWM故障检测器可以在检测到有效故障或故障信号时通知用户。如果有一些函数因该在事件发生时调用，这些函数应该通过<code>mcpwm_fault_register_event_callbacks()</code>连接到中断服务路径中。</p><p>回调函数的原型定义在<code>mcpwm_fault_event_cb_t</code></p><p>所有支持的事件回调如下：</p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N29mcpwm_fault_event_callbacks_t14on_fault_enterE"><code>mcpwm_fault_event_callbacks_t::on_fault_enter</code></a> 设置进入故障时的回调函数</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N29mcpwm_fault_event_callbacks_t13on_fault_exitE"><code>mcpwm_fault_event_callbacks_t::on_fault_exit</code></a> 设置故障解决时的回调函数</li></ul><p>回调函数在ISR上下文中调用，所以不能尝试阻塞</p><p><code>mcpwm_fault_register_event_callbacks()</code>的<code>user_data</code>参数用于传参数给回调函数。</p><p>这个函数将会延迟MCPWM故障中断服务的安装，而该服务只能在<code>MCPWM_del_fault</code>中删除。</p><h3 id="注册刹车时间回调"><a href="#注册刹车时间回调" class="headerlink" title="注册刹车时间回调"></a>注册刹车时间回调</h3><p>MCPWM操作器可以在实行刹车操作时通知用户。如果有函数需要在此时调用，可以将之连接到中断服务类路径中。</p><p>函数：<code>mcpwm_fault_register_event_callbacks()</code></p><p>回调函数原型：<code>mcpwm_brake_event_cb_t</code></p><p>所有支持的回调事件列在<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv432mcpwm_operator_event_callbacks_t"><code>mcpwm_operator_event_callbacks_t</code></a> 结构体中：</p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N32mcpwm_operator_event_callbacks_t12on_brake_cbcE"><code>mcpwm_operator_event_callbacks_t::on_brake_cbc</code></a> 设置操作器准备采取CBC动作时的回调函数</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N32mcpwm_operator_event_callbacks_t12on_brake_ostE"><code>mcpwm_operator_event_callbacks_t::on_brake_ost</code></a> 设置操作器准备采用OST动作时的回调函数</li></ul><p>回调函数在ISR上下文中调用，所以不能尝试阻塞</p><p><code>mcpwm_operator_register_event_callbacks()</code>的<code>user_data</code>参数用于传参数给回调函数。</p><p>这个函数将会延迟MCPWM故障中断服务的安装，而该服务只能在<code>MCPWM_del_fault</code>中删除。</p><h2 id="生成器强制动作"><a href="#生成器强制动作" class="headerlink" title="生成器强制动作"></a>生成器强制动作</h2><p>软件可以在运行中覆盖生成器的输出电平，函数：<code>mcpwm_generator_set_force_level()</code></p><p>软件强制电平的优先级总是比事件动作高（如：<code>mcpwm_generator_set_actions_on_timer_event()</code>）。</p><ul><li>设置 <code>level</code> 为 -1 意味着失能强制动作，并且生成器的输出电平将会再次被事件动作控制</li><li>设置 <code>hold_on</code> 为 true, 强制输出电平将会在<code>level=-1</code> 前保持有效</li><li>设置 <code>hole_on</code> 为 false, 强制输出电平只会存在一小段事件，任何一个新来到的事件都可以覆盖它</li></ul><h2 id="同步化"><a href="#同步化" class="headerlink" title="同步化"></a>同步化</h2><p>当MCPWM定时器获得一个同步信号，它将会进入一个预先定义的相位（由计数值和计数方向决定）。</p><p>设置同步相位函数：<code>mcpwm_timer_set_phase_on_sync()</code></p><p>配置结构体：<code>mcpwm_timer)sync_phase_config_t</code></p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N31mcpwm_timer_sync_phase_config_t8sync_srcE"><code>mcpwm_timer_sync_phase_config_t::sync_src</code></a> 设置同步信号源。在 <a class="link" target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#mcpwm-sync-sources">MCPWM Sync Sources <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 中及那个讲述了如何创造一个同步信号源对象。特别地，如果这个被设定为<code>NULL</code>，驱动器将会失能MCPWM定时器的同步特性</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N31mcpwm_timer_sync_phase_config_t11count_valueE"><code>mcpwm_timer_sync_phase_config_t::count_value</code></a> 设置当同步信号到达时的计数值</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N31mcpwm_timer_sync_phase_config_t9directionE"><code>mcpwm_timer_sync_phase_config_t::direction</code></a> 设置当同步信号到达时的计数方向</li></ul><p>同样，MCPWM捕获计时器也可以被同步化。</p><p>设置同步相位函数：<code>mcpwm_capture_timer_set_phase_on_sync()</code></p><p>配置结构体：<code>mcpwm_capture_timer_sync_phase_config_t</code></p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N39mcpwm_capture_timer_sync_phase_config_t8sync_srcE"><code>mcpwm_capture_timer_sync_phase_config_t::sync_src</code></a> 设置同步信号源。在 <a class="link" target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#mcpwm-sync-sources">MCPWM Sync Sources <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 中及那个讲述了如何创造一个同步信号源对象。特别地，如果这个被设定为<code>NULL</code>，驱动器将会失能MCPWM捕获定时器的同步特性</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N39mcpwm_capture_timer_sync_phase_config_t11count_valueE"><code>mcpwm_capture_timer_sync_phase_config_t::count_value</code></a> 设置当同步信号到达时的计数值</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N39mcpwm_capture_timer_sync_phase_config_t9directionE"><code>mcpwm_capture_timer_sync_phase_config_t::direction</code></a> 设置当同步信号到达时的计数方向。注意，与MCPWM定时器不同，捕获定时器只支持一个计数方向<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N23mcpwm_timer_direction_t24MCPWM_TIMER_DIRECTION_UPE"><code>MCPWM_TIMER_DIRECTION_UP</code></a>.</li></ul><h3 id="通过GPIO同步"><a href="#通过GPIO同步" class="headerlink" title="通过GPIO同步"></a>通过GPIO同步</h3><p>![image-20240201095645347](E:\0_VS\6_Blog\chepeys_blog\source_posts\嵌入式\ESP32S3\外设API\4 电机控制PWM\image-20240201095645347.png)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static void example_setup_sync_strategy(mcpwm_timer_handle_t timers[])
{
    mcpwm_sync_handle_t gpio_sync_source = NULL;
    mcpwm_gpio_sync_src_config_t gpio_sync_config = {
        .group_id = 0,              // GPIO fault should be in the same group of the above timers
        .gpio_num = EXAMPLE_SYNC_GPIO,
        .flags.pull_down = true,
        .flags.active_neg = false,  // by default, a posedge pulse can trigger a sync event
    };
    ESP_ERROR_CHECK(mcpwm_new_gpio_sync_src(&amp;gpio_sync_config, &amp;gpio_sync_source));

    mcpwm_timer_sync_phase_config_t sync_phase_config = {
        .count_value = 0,                      // sync phase: target count value
        .direction = MCPWM_TIMER_DIRECTION_UP, // sync phase: count direction
        .sync_src = gpio_sync_source,          // sync source
    };
    for (int i = 0; i &lt; 3; i++) {
        ESP_ERROR_CHECK(mcpwm_timer_set_phase_on_sync(timers[i], &amp;sync_phase_config));
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h2><p>MCPWM捕获计时器的基本功能时记录任何捕获信号变为有效脉冲边缘的时间。之后，你可以用回调函数让这个时间转换为脉冲宽度和转变为物理数值（距离、速度）。例如，在BLDC（无刷直流电机）中，我们可以使用捕获子模块从霍尔传感器测转子位置。</p><p>![Example of Brushless DC Motor Control with MCPWM](E:\0_VS\6_Blog\chepeys_blog\source_posts\嵌入式\ESP32S3\外设API\4 电机控制PWM\mcpwm-bldc-control.png)</p><p>捕获定时器通常连接多个捕获通道，参考 <a class="link" target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#mcpwm-capture-timer-and-channels">MCPWM Capture Timer and Channels <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 中的资源分配。</p><h3 id="注册事件回调"><a href="#注册事件回调" class="headerlink" title="注册事件回调"></a>注册事件回调</h3><p>MCWPM可以在检测到合法信号边缘时通知用户。</p><p>注册回调函数以获得定时计数值函数，注册函数：<code>mcpwm_capture_channel_register_event_callbacks()</code></p><p>回调函数原型：<code>mcpwm_capture_event_cb_t</code></p><p>支持的捕获回调：<code>mcpwm_capture_event_callbacks_t</code></p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N31mcpwm_capture_event_callbacks_t6on_capE"><code>mcpwm_capture_event_callbacks_t::on_cap</code></a> 设定当捕获通道检测到合法边缘时的回调函数</li></ul><p>回调函数将会提供事件详细信息（<code>mcpwm_capture_event_data_t</code>类型）</p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N26mcpwm_capture_event_data_t8cap_edgeE"><code>mcpwm_capture_event_data_t::cap_edge</code></a> 得到捕获信号的边缘</li><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv4N26mcpwm_capture_event_data_t9cap_valueE"><code>mcpwm_capture_event_data_t::cap_value</code></a> 此时刻内的计数值</li></ul><p>为了转变捕获计数为时间戳，你需要通过<code>mcpwm_capture_timer_get_resolution()</code>获得捕获定时器的分辨率。</p><p>回调函数竟会在ISR上下文中调用，因此不因该尝试阻塞（如：确保仅使用带有ISR后缀的FreeeRTOS API）。</p><p>使用<code>mcpwm_capture_channel_register_event_callbacks()</code>的<code>user_data</code>参数可以保存自己的内容，它将会直接传给回调函数。</p><p>这个函数将会延迟MCPWM捕获通道中断服务的安装，而服务只能被<code>mcpwm_del_capture_channel</code>删除</p><h3 id="使能和失能捕获通道"><a href="#使能和失能捕获通道" class="headerlink" title="使能和失能捕获通道"></a>使能和失能捕获通道</h3><p>捕获通道被<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv425mcpwm_new_capture_channel24mcpwm_cap_timer_handle_tPK30mcpwm_capture_channel_config_tP26mcpwm_cap_channel_handle_t"><code>mcpwm_new_capture_channel()</code></a> 分配后不会使能。</p><p>使能函数：<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv428mcpwm_capture_channel_enable26mcpwm_cap_channel_handle_t"><code>mcpwm_capture_channel_enable()</code></a></p><p>失能函数：<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv429mcpwm_capture_channel_disable26mcpwm_cap_channel_handle_t"><code>mcpwm_capture_channel_disable()</code></a></p><p>如果中断服务函数被注册事件通道回调函数（<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv446mcpwm_capture_channel_register_event_callbacks26mcpwm_cap_channel_handle_tPK31mcpwm_capture_event_callbacks_tPv"><code>mcpwm_capture_channel_register_event_callbacks()</code></a>）延迟的话，使能函数调用时，也会打开中断服务。</p><h3 id="使能和失能捕获定时器"><a href="#使能和失能捕获定时器" class="headerlink" title="使能和失能捕获定时器"></a>使能和失能捕获定时器</h3><p>在捕获定时器IO操作之前，用户需要使能定时器。</p><p>使能函数：<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv426mcpwm_capture_timer_enable24mcpwm_cap_timer_handle_t"><code>mcpwm_capture_timer_enable()</code></a></p><p>失能函数：<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv427mcpwm_capture_timer_disable24mcpwm_cap_timer_handle_t"><code>mcpwm_capture_timer_disable()</code></a></p><p>使能函数内部完成如下功能：</p><ul><li>切换捕获定时器状态从<strong>初始化</strong>到<strong>已使能</strong></li><li>如果选用特定时钟源，则获得合适的功率管理锁。参考<a class="link" target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#power-management">Power management <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul><h3 id="开启和停止捕获定时器"><a href="#开启和停止捕获定时器" class="headerlink" title="开启和停止捕获定时器"></a>开启和停止捕获定时器</h3><p>开启定时器：<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv425mcpwm_capture_timer_start24mcpwm_cap_timer_handle_t"><code>mcpwm_capture_timer_start()</code></a></p><p>关闭定时器：<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv424mcpwm_capture_timer_stop24mcpwm_cap_timer_handle_t"><code>mcpwm_capture_timer_stop()</code></a></p><h3 id="触发软件捕获器件"><a href="#触发软件捕获器件" class="headerlink" title="触发软件捕获器件"></a>触发软件捕获器件</h3><p>软件需要触发”假“捕获事件。</p><p>触发函数：<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv440mcpwm_capture_channel_trigger_soft_catch26mcpwm_cap_channel_handle_t"><code>mcpwm_capture_channel_trigger_soft_catch()</code></a></p><p>注意，即使是一个伪捕获时间，它也可以触发中断，因此也会调用回调函数。</p><h2 id="功率管理"><a href="#功率管理" class="headerlink" title="功率管理"></a>功率管理</h2><p>当电源管理使能（如：<a class="link" target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/kconfig.html#config-pm-enable">CONFIG_PM_ENABLE <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 打开），系统将会在轻睡眠前调整PLL、APB频率，因此潜在改变MCPWM定时器的计数周期导致不正确的时间。</p><p>然而，驱动可以通过功率锁（<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/system/power_management.html#_CPPv4N18esp_pm_lock_type_t19ESP_PM_APB_FREQ_MAXE"><code>ESP_PM_APB_FREQ_MAX</code></a>）来阻止系统改变APB频率。无论何时，驱动器创建一个以 <a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/clk_tree.html#_CPPv4N32soc_periph_mcpwm_timer_clk_src_t27MCPWM_TIMER_CLK_SRC_PLL160ME"><code>MCPWM_TIMER_CLK_SRC_PLL160M</code></a> 为时钟源的MCPWM定时器实例，驱动将会保证在定时器使能时（<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv418mcpwm_timer_enable20mcpwm_timer_handle_t"><code>mcpwm_timer_enable()</code></a>）获得功率管理锁。相反，在定时器失能时（<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv419mcpwm_timer_disable20mcpwm_timer_handle_t"><code>mcpwm_timer_disable()</code></a>）也会释放功率管理锁。</p><p>相似地，驱动器创建一个以 <a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/clk_tree.html#_CPPv4N34soc_periph_mcpwm_capture_clk_src_t25MCPWM_CAPTURE_CLK_SRC_APBE"><code>MCPWM_CAPTURE_CLK_SRC_APB</code></a> 为时钟源的MCPWM捕获定时器实例，驱动将会保证在定时器使能时（<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv426mcpwm_capture_timer_enable24mcpwm_cap_timer_handle_t"><code>mcpwm_capture_timer_enable()</code></a>）获得功率管理锁。相反，在定时器失能时（<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv427mcpwm_capture_timer_disable24mcpwm_cap_timer_handle_t"><code>mcpwm_capture_timer_disable()</code></a>）也会释放功率管理锁。</p><h2 id="IRAM安全"><a href="#IRAM安全" class="headerlink" title="IRAM安全"></a>IRAM安全</h2><p>默认情况下，当缓存因写入/擦除Flash等原因而被禁用时，MCPWM中断将被推迟。因此，事件回调函数将无法及时执行，在实时应用程序不期望的它的发生。</p><p>有一个Kconfig选项 <a class="link" target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/kconfig.html#config-mcpwm-isr-iram-safe">CONFIG_MCPWM_ISR_IRAM_SAFE <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，它将：</p><ol><li>即使缓存被禁用，也要启用正在服务的中断</li><li>将ISR使用的所有功能放入IRAM 中</li><li>将驱动程序对象放入DRAM（以防意外映射到PSRAM）</li></ol><p>这将允许中断在缓存被禁用时运行，但将以增加IRAM消耗为代价。</p><p>还有另一个Kconfig选项<a class="link" target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/kconfig.html#config-mcpwm-ctrl-func-in-iram">CONFIG_MCPWM_CTRL_FUNC_IN_IRAM <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，它也可以将常用的IO控制功能放入IRAM。因此，当缓存被禁用时，这些函数也可以执行。这些IO控制功能如下：</p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv434mcpwm_comparator_set_compare_value19mcpwm_cmpr_handle_t8uint32_t"><code>mcpwm_comparator_set_compare_value()</code></a></li></ul><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>像<a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv415mcpwm_new_timerPK20mcpwm_timer_config_tP20mcpwm_timer_handle_t"><code>mcpwm_new_timer()</code></a>这样的创建函数被驱动程序保证是线程安全的，这意味着你可以从不同的RTOS任务中调用它，而不需要额外的锁来保护。</p><p>以下函数允许在ISR上下文下运行，因为驱动程序使用关键部分来防止它们在任务和ISR中同时调用。</p><ul><li><a target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#_CPPv434mcpwm_comparator_set_compare_value19mcpwm_cmpr_handle_t8uint32_t"><code>mcpwm_comparator_set_compare_value()</code></a></li></ul><p>其他与资源分配无关的函数不是线程安全的。因此，应该避免在没有互斥保护的情况下在不同的任务中调用它们。</p><h2 id="Kconfig选项"><a href="#Kconfig选项" class="headerlink" title="Kconfig选项"></a>Kconfig选项</h2><ul><li><a class="link" target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/kconfig.html#config-mcpwm-isr-iram-safe">CONFIG_MCPWM_ISR_IRAM_SAFE <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 控制缓存被禁用时默认ISR处理程序是否可以工作，有关更多信息，请参阅<a class="link" target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#iram-safe">IRAM Safe <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/kconfig.html#config-mcpwm-ctrl-func-in-iram">CONFIG_MCPWM_CTRL_FUNC_IN_IRAM <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 控制MCPWM控制功能（IRAM或闪光灯）的放置位置，有关更多信息，请参阅I <a class="link" target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/peripherals/mcpwm.html#iram-safe">IRAM Safe <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://docs.espressif.com/projects/esp-idf/zh_CN/stable/esp32s3/api-reference/kconfig.html#config-mcpwm-enable-debug-log">CONFIG_MCPWM_ENABLE_DEBUG_LOG <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 用于启用调试日志输出。启用此选项将增加固件二进制大小。</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul><li>有刷直流电机PID速度控制： <a class="link" target="_blank" rel="noopener" href="https://github.com/espressif/esp-idf/tree/v5.1.2/examples/peripherals/mcpwm/mcpwm_bdc_speed_control">peripherals/mcpwm/mcpwm_bdc_speed_control <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>无刷直流电机霍尔传感器反馈：<a class="link" target="_blank" rel="noopener" href="https://github.com/espressif/esp-idf/tree/v5.1.2/examples/peripherals/mcpwm/mcpwm_bldc_hall_control">peripherals/mcpwm/mcpwm_bldc_hall_control <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>超声波传感器（HC-SR04）距离测量：<a class="link" target="_blank" rel="noopener" href="https://github.com/espressif/esp-idf/tree/v5.1.2/examples/peripherals/mcpwm/mcpwm_capture_hc_sr04">peripherals/mcpwm/mcpwm_capture_hc_sr04 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>伺服电机角度控制：<a class="link" target="_blank" rel="noopener" href="https://github.com/espressif/esp-idf/tree/v5.1.2/examples/peripherals/mcpwm/mcpwm_servo_control">peripherals/mcpwm/mcpwm_servo_control <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li><li>MCPWM定时器间同步：<a class="link" target="_blank" rel="noopener" href="https://github.com/espressif/esp-idf/tree/v5.1.2/examples/peripherals/mcpwm/mcpwm_sync">peripherals/mcpwm/mcpwm_sync <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li><strong>标题:</strong> 4 电机控制PWM</li><li><strong>作者:</strong> Chepey</li><li><strong>创建于 :</strong> 2024-01-27 17:03:00</li><li><strong>更新于 :</strong> 2024-02-01 11:13:52</li><li><strong>链接:</strong> https://chepey.github.io/2024/01/27/嵌入式/ESP32S3/外设API/4 电机控制PWM/</li><li><strong>版权声明: </strong>版权所有 &#169 Chepey，禁止转载。</li></ul></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/ESP32/">#ESP32</a>&nbsp;</li><li class="tag-item"><a href="/tags/ESP-IDF/">#ESP-IDF</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2024/02/01/%E5%B5%8C%E5%85%A5%E5%BC%8F/ESP32S3/%E5%A4%96%E8%AE%BEAPI/5%20SPI%E5%A4%96%E9%83%A8Flash%E8%AF%BB%E5%86%99/"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item">5 SPI及Flash读写</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2024/01/26/%E5%B5%8C%E5%85%A5%E5%BC%8F/ESP32S3/%E5%A4%96%E8%AE%BEAPI/3%20%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8/"><span class="title flex justify-center items-center"><span class="post-nav-title-item">3 通用定时器</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-right"></i></span></a></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">此页目录</div><div class="page-title">4 电机控制PWM</div><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6PWM"><span class="nav-number">1.</span> <span class="nav-text">电机控制PWM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E6%80%BB%E8%A7%88"><span class="nav-number">1.1.</span> <span class="nav-text">功能总览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.2.</span> <span class="nav-text">资源分配和初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MCPWM%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">1.2.1.</span> <span class="nav-text">MCPWM定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MCPWM%E6%93%8D%E4%BD%9C%E5%99%A8"><span class="nav-number">1.2.2.</span> <span class="nav-text">MCPWM操作器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MCPWM%E6%AF%94%E8%BE%83%E5%99%A8"><span class="nav-number">1.2.3.</span> <span class="nav-text">MCPWM比较器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MCPWM%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-number">1.2.4.</span> <span class="nav-text">MCPWM生成器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MCPWM%E6%95%85%E9%9A%9C"><span class="nav-number">1.2.5.</span> <span class="nav-text">MCPWM故障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MCPWM%E5%90%8C%E6%AD%A5%E6%BA%90"><span class="nav-number">1.2.6.</span> <span class="nav-text">MCPWM同步源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MCPWM%E6%8D%95%E8%8E%B7%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E9%80%9A%E9%81%93"><span class="nav-number">1.2.7.</span> <span class="nav-text">MCPWM捕获定时器和通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MCPWM%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.2.8.</span> <span class="nav-text">MCPWM中断优先级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.3.</span> <span class="nav-text">定时器操作和事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.1.</span> <span class="nav-text">注册事件回调函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E8%83%BD%E5%92%8C%E5%A4%B1%E8%83%BD%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">1.3.2.</span> <span class="nav-text">使能和失能定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%90%AF%E5%92%8C%E5%81%9C%E6%AD%A2%E6%97%B6%E9%92%9F"><span class="nav-number">1.3.3.</span> <span class="nav-text">开启和停止时钟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%8E%E6%93%8D%E4%BD%9C%E5%99%A8"><span class="nav-number">1.3.4.</span> <span class="nav-text">连接定时器与操作器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E5%99%A8%E5%8A%A8%E4%BD%9C%E4%B8%8E%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.4.</span> <span class="nav-text">比较器动作与事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-1"><span class="nav-number">1.4.1.</span> <span class="nav-text">注册事件回调函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%AF%94%E8%BE%83%E9%98%88%E5%80%BC"><span class="nav-number">1.4.2.</span> <span class="nav-text">设置比较阈值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E5%8A%A8%E4%BD%9C%E4%B8%8E%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.5.</span> <span class="nav-text">生成器动作与事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BA%8B%E4%BB%B6%E4%B8%AD%E8%AE%BE%E5%AE%9A%E7%94%9F%E6%88%90%E5%99%A8%E5%8A%A8%E4%BD%9C"><span class="nav-number">1.5.1.</span> <span class="nav-text">在定时器事件中设定生成器动作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%AF%94%E8%BE%83%E5%99%A8%E4%BA%8B%E4%BB%B6%E4%B8%AD%E8%AE%BE%E5%AE%9A%E7%94%9F%E6%88%90%E5%99%A8%E5%8A%A8%E4%BD%9C"><span class="nav-number">1.5.2.</span> <span class="nav-text">在比较器事件中设定生成器动作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8PWM%E6%B3%A2%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">1.6.</span> <span class="nav-text">经典PWM波和生成器配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%BE%B9%E9%9D%9E%E5%AF%B9%E7%A7%B0%E6%B3%A2%E5%BD%A2%EF%BC%88%E6%9C%89%E6%95%88%E7%94%B5%E5%B9%B3%EF%BC%9A%E9%AB%98%EF%BC%89"><span class="nav-number">1.6.1.</span> <span class="nav-text">单边非对称波形（有效电平：高）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%BE%B9%E9%9D%9E%E5%AF%B9%E7%A7%B0%E6%B3%A2%E5%BD%A2%EF%BC%88%E6%9C%89%E6%95%88%E7%94%B5%E5%B9%B3%EF%BC%9A%E4%BD%8E%EF%BC%89"><span class="nav-number">1.6.2.</span> <span class="nav-text">单边非对称波形（有效电平：低）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E8%84%89%E5%86%B2%E6%94%BE%E7%BD%AE"><span class="nav-number">1.6.3.</span> <span class="nav-text">非对称脉冲放置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E8%BE%B9%E9%9D%9E%E5%AF%B9%E7%A7%B0%E6%B3%A2%E5%BD%A2%EF%BC%88%E6%9C%89%E6%95%88%E7%94%B5%E5%B9%B3%EF%BC%9A%E4%BD%8E%EF%BC%89"><span class="nav-number">1.6.4.</span> <span class="nav-text">双边非对称波形（有效电平：低）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E8%BE%B9%E5%AF%B9%E7%A7%B0%E6%B3%A2%E5%BD%A2%EF%BC%88%E6%9C%89%E6%95%88%E7%94%B5%E5%B9%B3%EF%BC%9A%E4%BD%8E%EF%BC%89"><span class="nav-number">1.6.5.</span> <span class="nav-text">双边对称波形（有效电平：低）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E8%BE%B9%E5%AF%B9%E7%A7%B0%E6%B3%A2%E5%BD%A2%EF%BC%88%E4%BA%92%E8%A1%A5%EF%BC%89"><span class="nav-number">1.6.6.</span> <span class="nav-text">双边对称波形（互补）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E5%8C%BA%E6%97%B6%E9%97%B4"><span class="nav-number">1.7.</span> <span class="nav-text">死区时间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AD%A6%E5%91%8A"><span class="nav-number">1.7.1.</span> <span class="nav-text">警告</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8PWM%E6%B3%A2%E5%92%8C%E6%AD%BB%E5%8C%BA%E6%97%B6%E9%97%B4%E9%85%8D%E7%BD%AE"><span class="nav-number">1.8.</span> <span class="nav-text">经典PWM波和死区时间配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%94%B5%E5%B9%B3%E6%9C%89%E6%95%88%E3%80%81%E4%BA%92%E8%A1%A5"><span class="nav-number">1.8.1.</span> <span class="nav-text">高电平有效、互补</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8E%E7%94%B5%E5%B9%B3%E6%9C%89%E6%95%88%E3%80%81%E4%BA%92%E8%A1%A5"><span class="nav-number">1.8.2.</span> <span class="nav-text">低电平有效、互补</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%94%B5%E5%B9%B3%E6%9C%89%E6%95%88"><span class="nav-number">1.8.3.</span> <span class="nav-text">高电平有效</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8E%E7%94%B5%E5%B9%B3%E6%9C%89%E6%95%88"><span class="nav-number">1.8.4.</span> <span class="nav-text">低电平有效</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8A%E5%8D%87%E6%B2%BF%E5%BB%B6%E8%BF%9F%EF%BC%8CPWMB%E8%B7%B3%E8%BF%87"><span class="nav-number">1.8.5.</span> <span class="nav-text">上升沿延迟，PWMB跳过</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PWMB%E4%B8%8B%E9%99%8D%E6%B2%BF%E5%BB%B6%E8%BF%9F%EF%BC%8CPWMA%E8%B7%B3%E8%BF%87"><span class="nav-number">1.8.6.</span> <span class="nav-text">PWMB下降沿延迟，PWMA跳过</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PWMB%E4%B8%8A%E5%8D%87%E6%B2%BF%E3%80%81%E4%B8%8B%E9%99%8D%E6%B2%BF%E5%BB%B6%E8%BF%9F%EF%BC%8CPWMA%E8%B7%B3%E8%BF%87"><span class="nav-number">1.8.7.</span> <span class="nav-text">PWMB上升沿、下降沿延迟，PWMA跳过</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%BD%E6%B3%A2%E8%B0%83%E5%88%B6"><span class="nav-number">1.9.</span> <span class="nav-text">载波调制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%85%E9%9A%9C%E5%8F%8A%E5%88%B9%E8%BD%A6%E5%8A%A8%E4%BD%9C"><span class="nav-number">1.10.</span> <span class="nav-text">故障及刹车动作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%95%85%E9%9A%9C%E6%97%B6%E6%93%8D%E4%BD%9C%E5%99%A8%E5%88%B9%E8%BD%A6%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.10.1.</span> <span class="nav-text">设置故障时操作器刹车模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%88%B9%E8%BD%A6%E4%BA%8B%E4%BB%B6%E6%97%B6%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%8A%A8%E4%BD%9C"><span class="nav-number">1.10.2.</span> <span class="nav-text">设置刹车事件时生成器的动作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E6%95%85%E9%9A%9C%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83"><span class="nav-number">1.10.3.</span> <span class="nav-text">注册故障事件回调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E5%88%B9%E8%BD%A6%E6%97%B6%E9%97%B4%E5%9B%9E%E8%B0%83"><span class="nav-number">1.10.4.</span> <span class="nav-text">注册刹车时间回调</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E5%BC%BA%E5%88%B6%E5%8A%A8%E4%BD%9C"><span class="nav-number">1.11.</span> <span class="nav-text">生成器强制动作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%8C%96"><span class="nav-number">1.12.</span> <span class="nav-text">同步化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87GPIO%E5%90%8C%E6%AD%A5"><span class="nav-number">1.12.1.</span> <span class="nav-text">通过GPIO同步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7"><span class="nav-number">1.13.</span> <span class="nav-text">捕获</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83"><span class="nav-number">1.13.1.</span> <span class="nav-text">注册事件回调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E8%83%BD%E5%92%8C%E5%A4%B1%E8%83%BD%E6%8D%95%E8%8E%B7%E9%80%9A%E9%81%93"><span class="nav-number">1.13.2.</span> <span class="nav-text">使能和失能捕获通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E8%83%BD%E5%92%8C%E5%A4%B1%E8%83%BD%E6%8D%95%E8%8E%B7%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">1.13.3.</span> <span class="nav-text">使能和失能捕获定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%90%AF%E5%92%8C%E5%81%9C%E6%AD%A2%E6%8D%95%E8%8E%B7%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">1.13.4.</span> <span class="nav-text">开启和停止捕获定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E8%BD%AF%E4%BB%B6%E6%8D%95%E8%8E%B7%E5%99%A8%E4%BB%B6"><span class="nav-number">1.13.5.</span> <span class="nav-text">触发软件捕获器件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%9F%E7%8E%87%E7%AE%A1%E7%90%86"><span class="nav-number">1.14.</span> <span class="nav-text">功率管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IRAM%E5%AE%89%E5%85%A8"><span class="nav-number">1.15.</span> <span class="nav-text">IRAM安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">1.16.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kconfig%E9%80%89%E9%A1%B9"><span class="nav-number">1.17.</span> <span class="nav-text">Kconfig选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-number">1.18.</span> <span class="nav-text">例子</span></a></li></ol></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2023</span> - 2024&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">Chepey</a></div><script data-swup-reload-script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">访问人数</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">总访问量</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span> <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.5.0</a></span></div><div>博客已运行 <span class="odometer" id="runtime_days"></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/libs/Swup.min.js"></script><script src="/js/libs/SwupSlideTheme.min.js"></script><script src="/js/libs/SwupScriptsPlugin.min.js"></script><script src="/js/libs/SwupProgressPlugin.min.js"></script><script src="/js/libs/SwupScrollPlugin.min.js"></script><script src="/js/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script src="/js/tools/imageViewer.js" type="module"></script><script src="/js/utils.js" type="module"></script><script src="/js/main.js" type="module"></script><script src="/js/layouts/navbarShrink.js" type="module"></script><script src="/js/tools/scrollTopBottom.js" type="module"></script><script src="/js/tools/lightDarkSwitch.js" type="module"></script><script src="/js/layouts/categoryList.js" type="module"></script><script src="/js/tools/localSearch.js" type="module"></script><script src="/js/tools/codeBlock.js" type="module"></script><script src="/js/tools/runtime.js"></script><script src="/js/libs/odometer.min.js"></script><link rel="stylesheet" href="/assets/odometer-theme-minimal.css"><script src="/js/libs/Typed.min.js"></script><script src="/js/plugins/typed.js" type="module"></script><div class="post-scripts" data-swup-reload-script><script src="/js/libs/anime.min.js"></script><script src="/js/tools/tocToggle.js" type="module"></script><script src="/js/layouts/toc.js" type="module"></script><script src="/js/plugins/tabs.js" type="module"></script></div></body></html>